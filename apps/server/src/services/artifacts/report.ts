import { prisma } from '../../lib/prisma';
import { Prisma } from '@prisma/client';
import { uploadArtifact, ArtifactRecord } from './store';
import { ExecutionPlan, ToolCallResult } from '@opsuna/shared';
import { nanoid } from 'nanoid';

export interface ReportData {
  execution: {
    id: string;
    prompt: string;
    status: string;
    riskLevel: string | null;
    createdAt: Date;
    completedAt: Date | null;
  };
  plan: ExecutionPlan | null;
  results: ToolCallResult[] | null;
  toolCalls: Array<{
    stepId: string;
    toolName: string;
    status: string;
    startedAt: Date | null;
    completedAt: Date | null;
    error: string | null;
  }>;
  auditLogs: Array<{
    action: string;
    actor: string;
    createdAt: Date;
  }>;
}

/**
 * Generate a markdown execution report.
 */
export function generateMarkdownReport(data: ReportData): string {
  const { execution, plan, results, toolCalls, auditLogs } = data;

  const lines: string[] = [];

  // Header
  lines.push(`# Execution Report`);
  lines.push('');
  lines.push(`**ID:** \`${execution.id}\``);
  lines.push(`**Status:** ${getStatusEmoji(execution.status)} ${execution.status.toUpperCase()}`);
  lines.push(`**Risk Level:** ${getRiskBadge(execution.riskLevel)}`);
  lines.push(`**Created:** ${execution.createdAt.toISOString()}`);
  if (execution.completedAt) {
    lines.push(`**Completed:** ${execution.completedAt.toISOString()}`);
    const duration = execution.completedAt.getTime() - execution.createdAt.getTime();
    lines.push(`**Duration:** ${formatDuration(duration)}`);
  }
  lines.push('');

  // Prompt
  lines.push('## Prompt');
  lines.push('');
  lines.push('```');
  lines.push(execution.prompt);
  lines.push('```');
  lines.push('');

  // Plan Summary
  if (plan) {
    lines.push('## Execution Plan');
    lines.push('');
    lines.push(`**Summary:** ${plan.summary}`);
    lines.push(`**Risk Reason:** ${plan.riskReason || 'N/A'}`);
    lines.push('');

    lines.push('### Steps');
    lines.push('');
    lines.push('| # | Tool | Description | Risk |');
    lines.push('|---|------|-------------|------|');
    for (const step of plan.steps) {
      lines.push(`| ${step.order} | \`${step.toolName}\` | ${step.description} | ${step.riskLevel} |`);
    }
    lines.push('');
  }

  // Execution Results
  if (results && results.length > 0) {
    lines.push('## Results');
    lines.push('');

    for (const result of results) {
      const statusEmoji = result.status === 'success' ? '‚úÖ' : '‚ùå';
      lines.push(`### ${statusEmoji} ${result.toolName}`);
      lines.push('');
      lines.push(`- **Status:** ${result.status}`);
      if (result.error) {
        lines.push(`- **Error:** ${result.error}`);
      }
      if (result.result) {
        lines.push('- **Output:**');
        lines.push('```json');
        lines.push(JSON.stringify(result.result, null, 2));
        lines.push('```');
      }
      lines.push('');
    }
  }

  // Tool Calls Timeline
  if (toolCalls.length > 0) {
    lines.push('## Timeline');
    lines.push('');
    lines.push('| Time | Tool | Status | Duration |');
    lines.push('|------|------|--------|----------|');

    for (const call of toolCalls) {
      const time = call.startedAt ? call.startedAt.toISOString().split('T')[1].split('.')[0] : '-';
      const status = call.status === 'success' ? '‚úÖ' : call.status === 'error' ? '‚ùå' : '‚è≥';
      let duration = '-';
      if (call.startedAt && call.completedAt) {
        duration = formatDuration(call.completedAt.getTime() - call.startedAt.getTime());
      }
      lines.push(`| ${time} | \`${call.toolName}\` | ${status} ${call.status} | ${duration} |`);
    }
    lines.push('');
  }

  // Audit Log
  if (auditLogs.length > 0) {
    lines.push('## Audit Trail');
    lines.push('');
    for (const log of auditLogs) {
      const time = log.createdAt.toISOString();
      lines.push(`- **${time}** - ${log.action} (by ${log.actor})`);
    }
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push(`*Generated by Opsuna Tambo at ${new Date().toISOString()}*`);

  return lines.join('\n');
}

/**
 * Create a report artifact for an execution.
 */
export async function createExecutionReport(executionId: string): Promise<ArtifactRecord | null> {
  // Fetch execution data
  const execution = await prisma.execution.findUnique({
    where: { id: executionId },
    include: {
      toolCalls: {
        orderBy: { createdAt: 'asc' },
      },
      auditLogs: {
        orderBy: { createdAt: 'asc' },
      },
    },
  });

  if (!execution) {
    return null;
  }

  const reportData: ReportData = {
    execution: {
      id: execution.id,
      prompt: execution.prompt,
      status: execution.status,
      riskLevel: execution.riskLevel,
      createdAt: execution.createdAt,
      completedAt: execution.completedAt,
    },
    plan: execution.plan as unknown as ExecutionPlan | null,
    results: execution.results as unknown as ToolCallResult[] | null,
    toolCalls: execution.toolCalls.map((tc) => ({
      stepId: tc.stepId,
      toolName: tc.toolName,
      status: tc.status,
      startedAt: tc.startedAt,
      completedAt: tc.completedAt,
      error: tc.error,
    })),
    auditLogs: execution.auditLogs.map((al) => ({
      action: al.action,
      actor: al.actor,
      createdAt: al.createdAt,
    })),
  };

  const markdown = generateMarkdownReport(reportData);

  return uploadArtifact({
    executionId,
    type: 'report',
    name: `report-${executionId.slice(0, 8)}.md`,
    content: markdown,
    mimeType: 'text/markdown',
    metadata: {
      status: execution.status,
      riskLevel: execution.riskLevel,
      stepCount: execution.toolCalls.length,
    },
  });
}

/**
 * Create a shareable link for an execution report.
 */
export async function createSharedReport(
  executionId: string,
  expiresInHours?: number
): Promise<{ token: string; url: string } | null> {
  try {
    const token = nanoid(16);
    const expiresAt = expiresInHours
      ? new Date(Date.now() + expiresInHours * 60 * 60 * 1000)
      : null;

    await prisma.sharedReport.create({
      data: {
        executionId,
        token,
        expiresAt,
      },
    });

    // Generate URL (frontend will handle this route)
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    const url = `${baseUrl}/shared/${token}`;

    return { token, url };
  } catch (error) {
    console.error('[Report] Failed to create shared report:', error);
    return null;
  }
}

/**
 * Get a shared report by token.
 */
export async function getSharedReport(token: string): Promise<ReportData | null> {
  try {
    const shared = await prisma.sharedReport.findUnique({
      where: { token },
      include: {
        execution: {
          include: {
            toolCalls: { orderBy: { createdAt: 'asc' } },
            auditLogs: { orderBy: { createdAt: 'asc' } },
          },
        },
      },
    });

    if (!shared) {
      return null;
    }

    // Check expiration
    if (shared.expiresAt && shared.expiresAt < new Date()) {
      return null;
    }

    // Increment view count
    await prisma.sharedReport.update({
      where: { id: shared.id },
      data: { viewCount: { increment: 1 } },
    });

    const execution = shared.execution;

    return {
      execution: {
        id: execution.id,
        prompt: execution.prompt,
        status: execution.status,
        riskLevel: execution.riskLevel,
        createdAt: execution.createdAt,
        completedAt: execution.completedAt,
      },
      plan: execution.plan as unknown as ExecutionPlan | null,
      results: execution.results as unknown as ToolCallResult[] | null,
      toolCalls: execution.toolCalls.map((tc) => ({
        stepId: tc.stepId,
        toolName: tc.toolName,
        status: tc.status,
        startedAt: tc.startedAt,
        completedAt: tc.completedAt,
        error: tc.error,
      })),
      auditLogs: execution.auditLogs.map((al) => ({
        action: al.action,
        actor: al.actor,
        createdAt: al.createdAt,
      })),
    };
  } catch (error) {
    console.error('[Report] Failed to get shared report:', error);
    return null;
  }
}

// Helper functions

function getStatusEmoji(status: string): string {
  switch (status) {
    case 'completed':
      return '‚úÖ';
    case 'failed':
      return '‚ùå';
    case 'executing':
      return 'üîÑ';
    case 'cancelled':
      return 'üö´';
    default:
      return '‚è≥';
  }
}

function getRiskBadge(riskLevel: string | null): string {
  switch (riskLevel) {
    case 'HIGH':
      return 'üî¥ HIGH';
    case 'MEDIUM':
      return 'üü° MEDIUM';
    case 'LOW':
      return 'üü¢ LOW';
    default:
      return '‚ö™ Unknown';
  }
}

function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
  return `${(ms / 60000).toFixed(1)}m`;
}
